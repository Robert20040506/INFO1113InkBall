<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Ball.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">inkball_scaffold</a> &gt; <a href="index.source.html" class="el_package">inkball</a> &gt; <span class="el_source">Ball.java</span></div><h1>Ball.java</h1><pre class="source lang-java linenums">package inkball;

import processing.core.PImage;
import processing.core.PVector;

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

/**
 * Represents a ball in the InkBall game.
 */
public class Ball extends GameObject {

    public static final int RADIUS = 12;
<span class="fc" id="L16">    private static final Random RANDOM = new Random();</span>

    private PVector velocity;
    private int color;
    private PImage image;
    private Set&lt;Tile&gt; surroundingTiles;

    /**
     * Constructs a new Ball object.
     *
     * @param centerX The x-coordinate of the ball's center.
     * @param centerY The y-coordinate of the ball's center.
     * @param color   The color code of the ball.
     * @param image   The image representing the ball.
     */
    public Ball(float centerX, float centerY, int color, PImage image) {
<span class="fc" id="L32">        super(centerX, centerY);</span>
<span class="fc" id="L33">        this.velocity = new PVector(getRandomVelocity(), getRandomVelocity());</span>
<span class="fc" id="L34">        this.color = color;</span>
<span class="fc" id="L35">        this.image = image;</span>
<span class="fc" id="L36">        this.surroundingTiles = new HashSet&lt;&gt;();</span>
<span class="fc" id="L37">    }</span>

    /**
     * Returns a random velocity component, either -2 or 2.
     *
     * @return The random velocity component.
     */
    private float getRandomVelocity() {
<span class="fc bfc" id="L45" title="All 2 branches covered.">        return RANDOM.nextBoolean() ? 2 : -2;</span>
    }

    /**
     * Updates the position of the ball based on its velocity and handles bouncing
     * off the edges.
     */
    public void updatePosition() {
<span class="fc" id="L53">        centerXPosition += velocity.x;</span>
<span class="fc" id="L54">        centerYPosition += velocity.y;</span>

        // Bounce off the edges of the screen
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (centerXPosition - RADIUS &lt; 0) {</span>
<span class="fc" id="L58">            centerXPosition = RADIUS;</span>
<span class="fc" id="L59">            velocity.x *= -1;</span>
        }
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (centerXPosition + RADIUS &gt; App.WIDTH) {</span>
<span class="fc" id="L62">            centerXPosition = App.WIDTH - RADIUS;</span>
<span class="fc" id="L63">            velocity.x *= -1;</span>
        }
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (centerYPosition - RADIUS &lt; 0) {</span>
<span class="fc" id="L66">            centerYPosition = RADIUS;</span>
<span class="fc" id="L67">            velocity.y *= -1;</span>
        }
<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (centerYPosition + RADIUS &gt; App.HEIGHT) {</span>
<span class="fc" id="L70">            centerYPosition = App.HEIGHT - RADIUS;</span>
<span class="fc" id="L71">            velocity.y *= -1;</span>
        }
<span class="fc" id="L73">    }</span>

    /**
     * Checks the surrounding tiles for collisions and handles interactions.
     *
     * @param board The game board.
     */
    public void checkSurrounding(Tile[][] board) {
<span class="fc" id="L81">        int row = (int) (centerYPosition / App.CELL_SIZE);</span>
<span class="fc" id="L82">        int column = (int) (centerXPosition / App.CELL_SIZE);</span>

        // Clear previous surrounding tiles
<span class="fc" id="L85">        surroundingTiles.clear();</span>

<span class="fc bfc" id="L87" title="All 8 branches covered.">        if (row &lt; 0 || row &gt; 17 || column &lt; 0 || column &gt; 17) {</span>
<span class="fc" id="L88">            return;</span>
        }

        // Get surrounding tiles
        // Above
<span class="pc bpc" id="L93" title="1 of 4 branches missed.">        if (row &gt; 0 &amp;&amp; board[row - 1][column] != null) {</span>
<span class="fc" id="L94">            surroundingTiles.add(board[row - 1][column]);</span>
        }
        // Below
<span class="pc bpc" id="L97" title="1 of 4 branches missed.">        if (row &lt; App.BOARD_SIZE - 1 &amp;&amp; board[row + 1][column] != null) {</span>
<span class="fc" id="L98">            surroundingTiles.add(board[row + 1][column]);</span>
        }
        // Left
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">        if (column &gt; 0 &amp;&amp; board[row][column - 1] != null) {</span>
<span class="fc" id="L102">            surroundingTiles.add(board[row][column - 1]);</span>
        }
        // Right
<span class="pc bpc" id="L105" title="1 of 4 branches missed.">        if (column &lt; App.BOARD_SIZE - 1 &amp;&amp; board[row][column + 1] != null) {</span>
<span class="fc" id="L106">            surroundingTiles.add(board[row][column + 1]);</span>
        }
        // Current Tile
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (board[row][column] != null) {</span>
<span class="fc" id="L110">            surroundingTiles.add(board[row][column]);</span>
        }

        // Collision detection with surrounding tiles
<span class="fc bfc" id="L114" title="All 2 branches covered.">        for (Tile tile : surroundingTiles) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (tile instanceof Wall) {</span>
<span class="fc" id="L116">                Wall wall = (Wall) tile;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">                if (wall.collidesWithBall(this)) {</span>
<span class="fc" id="L118">                    wall.handleCollision(this);</span>
                }
<span class="fc bfc" id="L120" title="All 2 branches covered.">            } else if (tile instanceof Hole) {</span>
<span class="fc" id="L121">                Hole hole = (Hole) tile;</span>
<span class="fc" id="L122">                float distance = distanceTo(hole);</span>

<span class="fc bfc" id="L124" title="All 2 branches covered.">                if (distance &lt;= Hole.ATTRACTION_RADIUS) {</span>
<span class="fc" id="L125">                    hole.handleAttraction(this, distance);</span>
                    // Resize the ball image based on the distance to the hole
<span class="fc" id="L127">                    image = App.getInstance().getBallImage(color).copy();</span>
<span class="fc" id="L128">                    int scaledSize = (int) (distance / Hole.ATTRACTION_RADIUS * 2 * RADIUS);</span>
<span class="fc" id="L129">                    image.resize(scaledSize, scaledSize);</span>
                }
            }
<span class="fc" id="L132">        }</span>
<span class="fc" id="L133">    }</span>

    /**
     * Handles collision with a drawn line.
     *
     * @param lineStart The start point of the line segment.
     * @param lineEnd   The end point of the line segment.
     * @return True if collision occurred, false otherwise.
     */
    public boolean handleCollisionWithLine(PVector lineStart, PVector lineEnd) {
<span class="fc" id="L143">        PVector futurePosition = PVector.add(new PVector(centerXPosition, centerYPosition), velocity);</span>
<span class="fc" id="L144">        float distance = App.distPointToSegment(futurePosition, lineStart, lineEnd);</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (distance &lt;= RADIUS) {</span>
<span class="fc" id="L147">            PVector normalVector = calculateNormal(futurePosition, lineStart, lineEnd);</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">            if (normalVector.mag() != 0) {</span>
<span class="fc" id="L150">                normalVector.normalize();</span>
<span class="fc" id="L151">                float dotProduct = PVector.dot(velocity, normalVector);</span>
<span class="fc" id="L152">                velocity = PVector.sub(velocity, PVector.mult(normalVector, 2 * dotProduct));</span>
<span class="fc" id="L153">                return true;</span>
            }
        }

<span class="fc" id="L157">        return false;</span>
    }

    /**
     * Calculates the normal vector from a point to a line segment.
     *
     * @param point The point.
     * @param A     The start point of the line segment.
     * @param B     The end point of the line segment.
     * @return The normal vector.
     */
    public PVector calculateNormal(PVector point, PVector A, PVector B) {
<span class="fc" id="L169">        PVector direction = PVector.sub(B, A);</span>
<span class="fc" id="L170">        float dirMagSq = PVector.dot(direction, direction);</span>

<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (dirMagSq == 0) {</span>
            // The line segment is a point
<span class="fc" id="L174">            return PVector.sub(point, A);</span>
        }

<span class="fc" id="L177">        PVector PA = PVector.sub(point, A);</span>
<span class="fc" id="L178">        float projectionScale = PVector.dot(PA, direction) / dirMagSq;</span>
<span class="fc" id="L179">        PVector projection = PVector.mult(direction, projectionScale);</span>
<span class="fc" id="L180">        PVector normal = PVector.sub(PA, projection);</span>

<span class="fc" id="L182">        return normal;</span>
    }

    /**
     * Sets the color of the ball and updates its image.
     *
     * @param color The new color code.
     * @param image The new image.
     */
    public void setColor(int color, PImage image) {
<span class="fc" id="L192">        this.color = color;</span>
<span class="fc" id="L193">        this.image = image;</span>
<span class="fc" id="L194">    }</span>

    /**
     * Returns the color code of the ball.
     *
     * @return The color code.
     */
    public int getColor() {
<span class="fc" id="L202">        return color;</span>
    }

    /**
     * Returns the image of the ball.
     *
     * @return The image.
     */
    public PImage getImage() {
<span class="fc" id="L211">        return image;</span>
    }

    public float getCenterXPosition() {
<span class="fc" id="L215">        return centerXPosition;</span>
    }

    public void setCenterXPosition(float x) {
<span class="fc" id="L219">        centerXPosition = x;</span>
<span class="fc" id="L220">    }</span>

    public float getCenterYPosition() {
<span class="fc" id="L223">        return centerYPosition;</span>
    }

    public void setCenterYPosition(float y) {
<span class="fc" id="L227">        centerYPosition = y;</span>
<span class="fc" id="L228">    }</span>

    public Set&lt;Tile&gt; getSurroundingTiles() {
<span class="fc" id="L231">        return surroundingTiles;</span>
    }

    /**
     * Returns the velocity of the ball.
     *
     * @return The velocity vector.
     */
    public PVector getVelocity() {
<span class="fc" id="L240">        return velocity;</span>
    }

    /**
     * Sets the velocity of the ball.
     *
     * @param velocity The new velocity vector.
     */
    public void setVelocity(PVector velocity) {
<span class="fc" id="L249">        this.velocity = velocity;</span>
<span class="fc" id="L250">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>